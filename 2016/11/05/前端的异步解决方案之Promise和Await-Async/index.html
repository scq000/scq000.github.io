<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>前端的异步解决方案之Promise和Await/Async | Paolino</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">前端的异步解决方案之Promise和Await/Async</h1><a id="logo" href="/.">Paolino</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">前端的异步解决方案之Promise和Await/Async</h1><div class="post-meta">Nov 5, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/05/前端的异步解决方案之Promise和Await-Async/" href="/2016/11/05/前端的异步解决方案之Promise和Await-Async/#comments" class="ds-thread-count"></a><div class="post-content"><p>异步编程模式在前端开发过程中，显得越来越重要。从最开始的XHR到封装后的Ajax都在试图解决异步编程过程中的问题。随着ES6新标准的出来，处理异步数据流的解决方案又有了新的变化。<code>Promise</code>就是这其中的一个。我们都知道，在传统的ajax请求中，当异步请求之间的数据存在依赖关系的时候，就可能产生很难看的多层回调，俗称”回调地狱”（callback hell）。另一方面，往往错误处理的代码和正常的业务代码耦合在一起，造成代码会极其难看。为了让编程更美好，我们就需要引入<code>promise</code>来降低异步编程的复杂性。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p><strong>Promise</strong> 对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功返回值或失败信息指定处理方法。 这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的 <em>promise</em> 对象来替代原返回值。 ——<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN</a></p>
</blockquote>
<p>我们来看一下官方定义，Promise实际上就是一个特殊的Javascript对象，反映了”异步操作的最终值”。”Promise”直译过来有预期的意思，因此，它也代表了某种承诺，即无论你异步操作成功与否，这个对象最终都会返回一个值给你。<br>先写一个简单的demo来直观感受一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  $.ajax(<span class="string">'https://github.com/users'</span>, (value) =&gt;  &#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125;).fail(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    reject(err);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;,(err) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//也可以采取下面这种写法</span></div><div class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value)).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</div></pre></td></tr></table></figure></p>
<p>上面的例子，会在Ajax请求成功后调用<code>resolve</code>回调函数来处理结果，如果请求失败则调用<code>reject</code>回调函数来处理错误。Promise对象内部包含三种状态，分别为pending,fulfilled和rejected。这三种状态可以类比于我们平常在ajax数据请求过程的pending,success,error。一开始请求发出后，状态是Pending,表示正在等待处理完毕，这个状态是中间状态而且是单向不可逆的。成功获得值后状态就变为fulfilled，然后将成功获取到的值存储起来，后续可以通过调用<code>then</code>方法传入的回调函数来进一步处理。而如果失败了的话，状态变为rejected,错误可以选择抛出（throw)或者调用<code>reject</code>方法来处理。</p>
<p>请求的几个状态：</p>
<ol>
<li>pending（ 中间状态）—&gt; fulfilled , rejected</li>
<li>fulfilled（最终态）—&gt; 返回value 不可变</li>
<li>rejected（最终态） —&gt; 返回reason 不可变</li>
</ol>
<p>如图所示：</p>
<p> <img src="/images/promises.png" alt="promises"></p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a><a href="">promise</a></h2><p>一个promise内部可以返回另一个promise，这样就可以进行层级调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getAllUsers = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  $.ajax(<span class="string">'https://github.com/users'</span>, (value) =&gt;  &#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125;).fail(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    reject(err);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> getUserProfile = <span class="function"><span class="keyword">function</span>(<span class="params">username</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  $.ajax(<span class="string">'https://github.com/users'</span> + username, (value) =&gt;  &#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125;).fail(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    reject(err);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getAllUsers.then(<span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">//获取第一个用户的信息</span></div><div class="line">  <span class="keyword">return</span> getUserProfile(users[<span class="number">0</span>]);</div><div class="line"> &#125;).then(<span class="function">(<span class="params">profile</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(profile)</div><div class="line"> &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err));</div></pre></td></tr></table></figure>
<h2 id="Promise实现原理"><a href="#Promise实现原理" class="headerlink" title="Promise实现原理"></a>Promise实现原理</h2><p>目前，有多种Promise的实现方式，我选择了<a href="https://github.com/then/promise" target="_blank" rel="external">https://github.com/then/promise</a>的源码进行阅读。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> state = <span class="literal">null</span>; <span class="comment">//用以保存处理状态，true为fulfilled状态，false为rejected状态</span></div><div class="line">    <span class="keyword">var</span> value = <span class="literal">null</span>; <span class="comment">//用以保存处理结果值</span></div><div class="line">    <span class="keyword">var</span> deferreds = []; </div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> self.constructor(</div><div class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125;</div><div class="line">        );</div><div class="line">    &#125;; <span class="comment">//返回一个延迟处理函数，调用这个方法，就能触发用户传入的处理函数，分别对应处理promise的fulfilled状态和rejected状态</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">deferred</span>) </span>&#123;...&#125; <span class="comment">//延迟队列处理</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;...&#125; <span class="comment">//更新value值，并把state更新为true,代表结果正常</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">newValue</span>) </span>&#123;...&#125; <span class="comment">//更新vlaue值，并把state更新为false,代表结果错误，这个value值就是错误原因方便后面调用处理</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">finale</span>(<span class="params"></span>) </span>&#123;...&#125; <span class="comment">//清空异步队列</span></div><div class="line">    </div><div class="line">    doResolve(fn, resolve, reject); <span class="comment">//调用resolve和reject两个回调函数处理结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过阅读<a href="https://github.com/then/promise" target="_blank" rel="external">promise</a>的源码，我们可以很清楚地看到，在构建一个promise对象的时候，是利用函数式编程的特性，如惰性求值和部分求值等来进行将异步处理的。而处理多线程并发的机制就是利用<code>setTimeout(fn,0)</code>这个技巧。</p>
<h2 id="构造Promise"><a href="#构造Promise" class="headerlink" title="构造Promise"></a>构造Promise</h2><p>Promise构造函数的初始函数需要有两个参数，resolve和reject，分别对应fulfilled和rejected两个状态的处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">var</span> value = doSomething();</div><div class="line">    resolve(value);</div><div class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">    reject(err);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Promise的常用方法"><a href="#Promise的常用方法" class="headerlink" title="Promise的常用方法"></a>Promise的常用方法</h2><p>1.Promise.all(iterator):</p>
<p>​    返回一个新的<code>promise</code>对象，其中所有promise的对象成功触发的时候，该对象才会触发成功，若有任何一个发成错误，就会触发改对象的失败方法。成功触发的返回值是所有promise对象返回值组成的数组。直接看例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置三个任务</span></div><div class="line"><span class="keyword">const</span> tasks = &#123;</div><div class="line">  task1() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(...); <span class="comment">//return 1</span></div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  task2() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(...); <span class="comment">// return 2</span></div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  task3() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(...); <span class="comment">// return 3</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//列表中的所有任务会并发执行，当所有任务执行状态都为fulfilled后，执行then方法</span></div><div class="line"><span class="built_in">Promise</span>.all([tasks.task1(), tasks.task2(), tasks.task3()]).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));</div><div class="line"><span class="comment">//最终结果为：[1,2,3]</span></div></pre></td></tr></table></figure>
<p>2.Promise.race(iterable): 返回一个新的<code>promise</code>对象，其回调函数迭代遍历每个值，分别处理。同样都是传入一组promise对象进行处理，同Promise.all不同的是，只要其中有一个promise的状态变为<code>fulfilled</code>或<code>rejected</code>，就会调用后续的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置三个任务</span></div><div class="line"><span class="keyword">const</span> tasks = &#123;</div><div class="line">  task1() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(...); <span class="comment">//return 1</span></div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  task2() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(...); <span class="comment">// return 2</span></div><div class="line">  &#125;,</div><div class="line">  </div><div class="line">  task3() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(...); <span class="comment">// return 3</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//列表中的所有任务会并发执行，只要有一个promise对象出现结果，就会执行then方法</span></div><div class="line"><span class="built_in">Promise</span>.race([tasks.task1(), tasks.task2(), tasks.task3()]).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result));</div><div class="line"><span class="comment">//假设任务1最开始返回结果，则控制台打印结果为`1`</span></div></pre></td></tr></table></figure>
<p>3.Promise.reject(reason)： 返回一个新的<code>promise</code>对象，用reason值直接将状态变为<code>rejected</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  reject(<span class="string">'Failed'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.reject(<span class="string">'Failed'</span>);</div></pre></td></tr></table></figure>
<p>上面两种写法是等价的。</p>
<p>4.Promise.resolve(value): 返回一个新的promise对象，这个promise对象是被resolved的。</p>
<p>与reject类似，下面这两种写法也是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  resolve(<span class="string">'Success'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="string">'Success'</span>);</div></pre></td></tr></table></figure>
<p>5.then  利用这个方法访问值或者错误原因。其回调函数就是用来处理异步处理返回值的。</p>
<p>6.catch 利用这个方法捕获错误，并处理。</p>
<h1 id="Generator-amp-Iterator-迭代器和生成器"><a href="#Generator-amp-Iterator-迭代器和生成器" class="headerlink" title="Generator &amp; Iterator 迭代器和生成器"></a>Generator &amp; Iterator 迭代器和生成器</h1><p>虽然Promise解决了回调地狱（callback hell)的问题，但是仍然需要在使用的时候考虑到非同步的情况，而有没有什么办法能让异步处理的代码写起来更简单呢？在介绍解决方案之前，我们先来介绍一下ES6中有的迭代器和生成器。<br>迭代器(Iterator)，顾名思义，它的作用就是用来迭代遍历集合对象。<br>在ES6语法中迭代器是一个有<code>next</code>方法的对象，可以利用<code>Symbol.iterator</code>的标志返回一个迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getNum = &#123;</div><div class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      next() &#123;</div><div class="line">        <span class="keyword">return</span> i &lt; arr.length ? &#123;<span class="attr">value</span>: arr[i++]&#125; : &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//利用for...of语法遍历迭代器</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> getNum) &#123;</div><div class="line">  <span class="built_in">console</span>.log(num);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而生成器(Generator)可以看做一个特殊的迭代器，你可以不用纠结迭代器的定义形式，使用更加友好地方式实现代码逻辑。<br>先来看一段简单的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getNum</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用生成器，生成一个可迭代的对象</span></div><div class="line"><span class="keyword">const</span> gen = getNum(); </div><div class="line"></div><div class="line">gen.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></div><div class="line">gen.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></div><div class="line">gen.next(); <span class="comment">// &#123;value: 3, done: true&#125;</span></div></pre></td></tr></table></figure></p>
<p>生成器函数的定义需要使用<code>function*</code>的形式，这也是它和普通函数定义的区别。<code>yield</code>是一个类似<code>return</code>的关键字，当代码执行到这里的时候，会暂停当前函数的执行，并保存当前的堆栈信息，返回<code>yield</code>后面跟着表达式的值，这个值就是上面代码所看到的<code>value</code>所对应的值。而<code>done</code>这个属性表示是否还有更多的元素。当<code>done</code>为<code>true</code>的时候，就表明这个迭代过程结束了。需要注意的是这个<code>next</code>方法其实传入参数，这个参数表示上一个<code>yield</code>语句的返回值，如果你给<code>next</code>方法传入了参数，就会将上一次<code>yield</code>语句的值设置为对应值。</p>
<h2 id="利用generator的异步处理"><a href="#利用generator的异步处理" class="headerlink" title="利用generator的异步处理"></a>利用generator的异步处理</h2><p>先来看一下下面这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    gen.next(<span class="string">'hello'</span>);</div><div class="line">  &#125;,<span class="number">2000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLastName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    gen.next(<span class="string">'world'</span>);</div><div class="line">  &#125;,<span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">say</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> firstName = <span class="keyword">yield</span> getFirstName();</div><div class="line">  <span class="keyword">let</span> lastName = <span class="keyword">yield</span> getLastName();</div><div class="line">  <span class="built_in">console</span>.log(firstName + lastName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = say();</div><div class="line"></div><div class="line">gen.next(); <span class="comment">// &#123;value: undefined, done: false&#125;</span></div><div class="line"><span class="comment">//helloworld</span></div></pre></td></tr></table></figure></p>
<p>我们可以发现，当第一次调用<code>gen.next()</code>后，程序执行到第一个<code>yield</code>语句就中断了,而在<code>getFirstName</code>里显式地将上一个<code>yield</code>语句的返回值改为<code>hello</code>,触发了第二<code>yield</code>语句的执行。以此类推，最终就打印出我们想要的结果了。</p>
<h2 id="spawn函数"><a href="#spawn函数" class="headerlink" title="spawn函数"></a>spawn函数</h2><p>我们可以考虑把上面的代码改写一下，在这里将Promise和Generator结合起来，将异步操作用<code>Promise</code>对象封装好，然后，<code>resolve</code>出去，而创建一个<code>spawn</code>函数，这个函数的作用是自动触发<code>generator</code>的<code>next</code>方法。来看一下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(<span class="string">'hello'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLastName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(<span class="string">'world'</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">say</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> firstName = <span class="keyword">yield</span> getFirstName();</div><div class="line">  <span class="keyword">let</span> lastName = <span class="keyword">yield</span> getLastName();</div><div class="line">  <span class="built_in">console</span>.log(firstName + lastName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">generator</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> onResult =  <span class="function">(<span class="params">lastPromiseResult</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">var</span> &#123;value, done&#125; = generator.next(lastPromiseResult);</div><div class="line">      <span class="keyword">if</span>(!done) &#123;</div><div class="line">        value.then(onResult, reject);</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        resolve(value);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    onResult();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(say()).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(value)&#125;);</div></pre></td></tr></table></figure></p>
<p>到这里，这个解决方案就很接近接下来要介绍的async/await的实现方式了。</p>
<h1 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h1><p>这两个关键字其实是一起使用的，<code>async</code>函数其实就相当于<code>funciton *</code>的作用，而<code>await</code>就相当与<code>yield</code>的作用。而在<code>async/await</code>机制中，自动包含了我们上述封装出来的<code>spawn</code>自动执行函数。<br>利用这两个新的关键字，可以让代码更加简洁和明了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</div><div class="line">      resolve(<span class="string">'hello'</span>);</div><div class="line">    &#125;, <span class="number">2000</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLastName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'world'</span>);</div><div class="line">      resolve(<span class="string">'world'</span>);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> firstName = <span class="keyword">await</span> getFirstName();</div><div class="line">  <span class="keyword">let</span> secondName = <span class="keyword">await</span> getLastName();</div><div class="line">  <span class="keyword">return</span> firstName + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(say());</div></pre></td></tr></table></figure></p>
<p>执行结果为，先等待2秒打印hello,再等待1秒打印world，最后打印’helloworld’，与预期的执行顺序是一致的。</p>
<p>上面的代码你需要注意的是，你必须显式声明<code>await</code>，否则你会得到一个<code>promise</code>对象而不是你想要获得的值。</p>
<p>比起<code>Generator</code>函数,<code>async/await</code>的语义更好，代码写起来更加自然。将异步处理的逻辑放在语法层面去处理，写的代码也更加符合人的自然思考方式。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>对于async/await这种方法来说，错误处理也比较符合我们平常编写同步代码时候处理的逻辑，直接使用try..catch就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> $.ajax(<span class="string">'https://github.com/users'</span>);  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getFirstUser</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">let</span> users = <span class="keyword">await</span> getUsers();</div><div class="line"> 		<span class="keyword">return</span> users[<span class="number">0</span>].name;</div><div class="line">	&#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">     	<span class="keyword">return</span> &#123;</div><div class="line">          <span class="attr">name</span>: <span class="string">'default user'</span></div><div class="line">     	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>目前，<a href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/" target="_blank" rel="external">Service Workers</a>、 <a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">Fetch</a>、 <a href="https://streams.spec.whatwg.org/" target="_blank" rel="external">Streams</a>、<a href="https://whatwg.github.io/loader/" target="_blank" rel="external">Loader</a> 等全部基于 Promise。可以预见，在未来的Javascript异步编程中，Promise及其衍生出来的技术必将大放异彩。那么，你准备好了吗？</p>
<h1 id="Read-More"><a href="#Read-More" class="headerlink" title="Read More"></a><em>Read More</em></h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN Promise</a><br><a href="https://www.promisejs.org/" target="_blank" rel="external">https://www.promisejs.org/</a><br><a href="https://promisesaplus.com/" target="_blank" rel="external">https://promisesaplus.com/</a><br><a href="https://ponyfoo.com/articles/es6-promises-in-depth" target="_blank" rel="external">es6 promises in depth</a><br><a href="understanding javascript async await">https://ponyfoo.com/articles/understanding-javascript-async-await</a><br><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">ECMAScript 6入门</a><br><a href="http://www.cnblogs.com/silin6/p/4333999.html" target="_blank" rel="external">Javascript下的setTimeout(fn,0)意味着什么？</a><br><a href="https://www.youtube.com/watch?v=lil4YCCXRYc" target="_blank" rel="external">https://www.youtube.com/watch?v=lil4YCCXRYc</a> 视频<br><a href="https://channel9.msdn.com/Events/Build/2015/3-644" target="_blank" rel="external">https://channel9.msdn.com/Events/Build/2015/3-644</a><br><a href="http://efe.baidu.com/blog/promises-anti-pattern/" target="_blank" rel="external">谈谈使用 promise 时候的一些反模式</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/11/05/前端的异步解决方案之Promise和Await-Async/" data-id="cj636vubj000cpg2koonxdew0" class="article-share-link">分享到</a><div class="tags"><a href="/tags/javascript/">javascript</a><a href="/tags/异步/">异步</a></div><div class="post-nav"><a href="/2016/11/05/CSS中的长度单位/" class="pre">CSS中的长度单位</a><a href="/2016/10/29/谈一谈响应式编程/" class="next">谈一谈响应式编程</a></div><div data-thread-key="2016/11/05/前端的异步解决方案之Promise和Await-Async/" data-title="前端的异步解决方案之Promise和Await/Async" data-url="http://yoursite.com/2016/11/05/前端的异步解决方案之Promise和Await-Async/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/05/前端的异步解决方案之Promise和Await-Async/" data-title="前端的异步解决方案之Promise和Await/Async" data-url="http://yoursite.com/2016/11/05/前端的异步解决方案之Promise和Await-Async/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/flexbox/" style="font-size: 15px;">flexbox</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/正则/" style="font-size: 15px;">正则</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/React中的五种组件形式/">React中的五种组件形式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/24/浅谈性能优化之Tree-Shaking/">浅谈性能优化之Tree Shaking</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/08/那些年，那些跨域问题/">那些年，那些跨域问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/响应式图片的处理/">响应式图片的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/ES6语言特性的总结-3/">ES6语言特性的总结(3)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/01/ES6语言特性的总结-2/">ES6语言特性的总结(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/26/ES6语言特性的总结-1/">ES6语言特性的总结(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/06/设计模式之状态模式/">设计模式之状态模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/IOS-Input-Disabled默认样式问题/">IOS Input Disabled默认样式问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/一个垂直居中的方法/">一个垂直居中的方法</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.jianshu.com/users/a817d4788c8a/latest_articles" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Paolino.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'myLife'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
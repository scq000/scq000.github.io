<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ES6语言特性的总结(2) | Paolino</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ES6语言特性的总结(2)</h1><a id="logo" href="/.">Paolino</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ES6语言特性的总结(2)</h1><div class="post-meta">Mar 1, 2017</div><div class="post-content"><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>ES6中对于数据做了进一步的增强,以便能够更加方便地创建数组以及操作数组。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h3><p>该方法用于将一组值转换为数组。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.of(<span class="number">1</span>); [<span class="number">1</span>]</span><br><span class="line">Array.of(<span class="number">3</span>, <span class="number">21</span>, <span class="number">22</span>); [<span class="number">3</span>,<span class="number">21</span>,<span class="number">22</span>]</span><br></pre></td></tr></table></figure>
<p>这个方法的出现主要是为了弥补之前数组构造函数的一些缺陷：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arry<span class="comment">()</span>; <span class="comment">// []</span></span><br><span class="line">Array<span class="comment">(3)</span>; <span class="comment">// [undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure></p>
<p>你会发现在使用单个数值参数的时候，那个参数被构造器作为数组长度而进行初始化。而两个参数以上的时候，则返回由参数构成的数组。而 Array.of() 方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。</p>
<h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p>该方法通常用于将类似数组的对象以及可遍历对象转换成数组。你可以将NodeList,Set,Map等等解构进行数组的转换。</p>
<p>利用该方法的第二个参数，你可以指定一个回调函数，用于对数组进行映射操作。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arguments为函数传入的参数</span></span><br><span class="line"><span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, <span class="function"><span class="params">value</span> =&gt;</span> value + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).map(<span class="function"><span class="params">value</span> =&gt;</span> value + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>该方法的第三个参数是上下文，在映射函数中如果需要使用<code>this</code>，需要手动传入该参数。</p>
<blockquote>
<p>在ES6中， Class 语法允许我们为内置类型（比如 Array）和自定义类新建子类（比如叫 SubArray）。这些子类也会继承父类的静态方法，比如 SubArray.from()，调用该方法后会返回子类 SubArray 的一个实例，而不是 Array 的实例。</p>
</blockquote>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>fill() 方法能使用特定值填充数组中的一个或多个元素。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].fill(<span class="number">1</span>); <span class="comment">//用1填充数组所有项 [1,1,1]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].fill(<span class="number">10</span>, <span class="number">2</span>); <span class="comment">//从索引2开始用10填充数组 [1, 2, 10]</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].fill(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">//从索引2到索引3之间开始用0填充数组 [1,2,0,4]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find/findIndex"></a>find/findIndex</h3><p>该方法的参数是一个回调函数，用于查找数组中满足回调函数测试的第一个值或者第一个索引(index)。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [<span class="number">1</span>,<span class="number">342</span>,<span class="number">342</span>,<span class="number">22</span>, <span class="number">34</span>, <span class="number">35</span>];</span><br><span class="line">console.log(numbers.find(n =&gt; n &gt; <span class="number">35</span>));         <span class="comment">// 342</span></span><br><span class="line">console.log(numbers.findIndex(n =&gt; n &gt; <span class="number">33</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h3><p>该方法用来复制自身元素，然后填充进数组里。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>针对可迭代的对象，ES6提供了三个新的方法：entries，keys, values分别用于返回键值对、键名、键值的迭代器，可以使用for…of语法进行访问。而数组的键名其实就是它的索引值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串的操作层面，ES6提供了模板对象、多行字符串的支持。</p>
<h2 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h2><p>在ES6中，我们可以使用反引号（` ）来包裹普通字符串。<br>在ES5，我们如果要生成一个多行的字符串，通常要使用<code>+</code>连字符，而现在只要使用反引号就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">`Courses are provided in MOOC format with course material available online, mostly as videos complemented with exercise and example files.</span></span><br><span class="line"><span class="string">All throughout the course, a technical expert will be available online to provide help and answer your questions.</span></span><br><span class="line"><span class="string">Each course takes approximately 6 to 7 hours to complete, depending on your proficiency, and must be completed within one week.`</span>;</span><br></pre></td></tr></table></figure>
<p>另外，我们可以在字符串模板中制造替换位，从而使用一些变量来填充我们的模板。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'scq000'</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// Hello,scq000</span></span><br></pre></td></tr></table></figure></p>
<p>###标签化模板</p>
<p>模板标签(template tag)能对模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定。标签实际上就是一个函数，它被调用时接收需要处理的模板字面量数据，然后进行处理后返回一个字符串。这个函数的第一个参数是一个数组，包含被JS解释过的字面量字符串，随后的参数是每个替换位的解释值。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(literals, <span class="rest_arg">...substitutions</span>)</span> </span>&#123;</span><br><span class="line">  let result = <span class="string">''</span>;</span><br><span class="line">  console.log(literals);</span><br><span class="line">  console.log(substitutions);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'scq000'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">let msg = tag`My name <span class="keyword">is</span> $&#123;name&#125;, and my age <span class="keyword">is</span> $&#123;age&#125;.`;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>literials</code>被赋值为<code>[&#39;My name is &#39;, [, and my age is ], [.]]</code>，而<code>substutions</code>则是<code>[&#39;scq000&#39;, 12]</code>，即用来替换的值。你可以在这个函数中，利用这两个信息对字符串做进一步的加工。</p>
<p>另外，有个内置的<code>String.raw</code>标签，可以直接获取模板字面量的原始值,即转义之前的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="built_in">String</span>.raw<span class="string">`hello$1\nworld`</span>；</span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">//hello$1\nworld</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串实例方法"><a href="#字符串实例方法" class="headerlink" title="字符串实例方法"></a>字符串实例方法</h2><p>对于字符串的实例方法上，新增了一些比较常用的方法。</p>
<ol>
<li>includes: 在给定文本存在于字符串中的任意位置时会返回 true ，否则返回 false 。</li>
<li>startsWith: 在给定文本出现在字符串起始处时返回 true ，否则返回 false 。</li>
<li>endsWith: 在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。</li>
</ol>
<p>需要注意的是，与之前<code>indexOf</code>等方法不同，以上这些实例方法的参数不能传入正则表达式，否则会抛出错误。</p>
<ol start="4">
<li>repeat: 接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。</li>
</ol>
<h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>从ES6开始，引入了第6个基本数据类型：符号(Symbol)。 它是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。</p>
<h2 id="创建符号值"><a href="#创建符号值" class="headerlink" title="创建符号值"></a>创建符号值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(); <span class="comment">//注意这里不能用new,因为Symbol是基本数据类型</span></span><br><span class="line"><span class="keyword">const</span> aname = <span class="built_in">Symbol</span>(<span class="string">'aname'</span>); <span class="comment">//提供的这个参数主要用来调试</span></span><br><span class="line"><span class="keyword">typeof</span> name <span class="comment">//"Symbol"</span></span><br></pre></td></tr></table></figure>
<h2 id="使用符号值"><a href="#使用符号值" class="headerlink" title="使用符号值"></a>使用符号值</h2><p>可以在任何能使用“计算属性名”的场合使用符号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">'first name'</span>);</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="built_in">Symbol</span>(<span class="string">'last name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [firstName]: <span class="string">'scq'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, firstName, &#123; <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">  [lastName]: &#123;</span><br><span class="line">    value: <span class="string">'000'</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的例子，为<code>person</code>对象定义了两个符号类型属性，并将它们设为只读的。利用这种方式，特别适合创建对象私有成员。</p>
<h2 id="暴露内部方法"><a href="#暴露内部方法" class="headerlink" title="暴露内部方法"></a>暴露内部方法</h2><p>利用Symbol的一些属性，可以针对对象的一些内部行为进行操作。</p>
<ol>
<li>Symbol.iterator： 一个返回对象默认迭代器的方法,使用for…of</li>
<li>Symbol.match： 一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用String.prototype.match</li>
<li>Symbol.replace：一个替换匹配字符串的子串的方法.使用String.prototype.replace</li>
<li>Symbol.search</li>
<li>Symbol.split</li>
<li>Symbol.hasInstance: 一个确定一个构造器对象识别的对象是否为它的实例的方法。使用 instanceof.</li>
<li>Symbol.isConcatSpreadable: 一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat().</li>
<li>Symbol.unscopables: 拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。</li>
<li>Symbol.species: 一个用于创建派生对象的构造器函数。.</li>
<li>Symbol.toPrimitive: 一个将对象转化为基本数据类型的方法。</li>
<li>Symbol.toStringTag： 用于对象的默认描述的字符串值。使用Object.prototype.toString().</li>
</ol>
<p>功能比较多，就不一一说明了。下面就以<code>iterator</code>来说明一下使用方法：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = &#123;</span><br><span class="line">  [Symbol.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      start: <span class="number">0</span>,</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.start &lt; <span class="number">10</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;value: <span class="keyword">this</span>.start ++, done: <span class="literal">false</span>&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;value: undefined, done: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value of iterator) &#123;</span><br><span class="line">  console.log(vlaue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子利用了<code>Symbol.iterator</code>这个属性，使得对象<code>iterator</code>获得了迭代器的能力。因此，可以对这个对象使用<code>for...of</code>的语法进行迭代操作。</p>
<h1 id="Set与Map"><a href="#Set与Map" class="headerlink" title="Set与Map"></a>Set与Map</h1><p>ES6中增加了两个新的数据结构，Set和Map，补充了原本数组的一些不足之处。Set 是不包含重复值的列表,而Map 则是键与相对应的值的集合。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set是一种无重复值的有序列表。<br>创建一个Set很简单，只要使用new关键字就可以了。Set的构造器实际上可以接受任何可迭代对象作为参数。在构造器内部，会使用迭代器来提取参数中的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//创建一个空的集合 Set &#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">//创建一个包含三个元素的集合, Set &#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="keyword">let</span> set3 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]); <span class="comment">//创建一个去重后的集合, Set &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>针对Set，主要提供了以下几个方法：</p>
<ol>
<li>add: 能向 Set 中添加项目</li>
<li>has: 测试某个值是否存在于 Set 中</li>
<li>delete: 来移除单个值</li>
<li>clear: 来将所有值从 Set 中移除<br>还提供了一个size属性用于判断集合长度</li>
</ol>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">set</span> = new <span class="comment">Set([1,2,3,4,5,6])</span>;</span><br><span class="line"><span class="keyword">set</span>.add(3); <span class="comment">//由于3已经在集合里了，并不会添加新项</span></span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">'nihao'</span>); <span class="comment">// Set &#123;1,2,3,4,5,6,'nihao'&#125;</span></span><br><span class="line"><span class="keyword">set</span>.has(3); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">set</span>.delete(3); <span class="comment">// Set &#123;1,2,4,5,6,'nihao'&#125;</span></span><br><span class="line"><span class="keyword">set</span>.clear(); <span class="comment">// Set &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意的是，当一个属性被添加到 set 对象时，它的值也被设为<code>true</code>。而在 Set 内部的比较使用了Object.is()方法，来判断两个值是否相等。</p>
<h3 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a>Set的遍历</h3><p>同数组一样，作为可迭代的数据结构，ES6提供了<code>forEach</code>的方法对其进行遍历。你也可以使用，<code>for...of</code>的语法进行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);</span><br><span class="line"><span class="keyword">set</span>.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Value: '</span> + value + <span class="string">' Key: '</span> + key));</span><br><span class="line"><span class="comment">//Value: a Key: a</span></span><br><span class="line"><span class="comment">//Value: b Key: b</span></span><br><span class="line"><span class="comment">//Value: c Key: c</span></span><br></pre></td></tr></table></figure>
<p>由于Set的每一项同时被认为键和值，因此，key和value其实是一致的。如果想在回调函数中使用 this ，你可以给 forEach() 传入一个 this 值作为第三个参数。你也可以使用箭头函数来达到同等的效果。</p>
<h3 id="转换成数组"><a href="#转换成数组" class="headerlink" title="转换成数组"></a>转换成数组</h3><p>要将Set转换成数组，可以像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(set); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line">[...set]; <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>使用扩展运算符可以更简单地将 Set 转换回数组。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map与Set相似，数据结构中存储着键值对。实例方法与Set相同的部分是has,delete,clear。你可以调用 set() 方法并给它传递一个键与一个关联的值，来给 Map 添加项；此后使用键名来调用 get() 方法便能提取对应的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'key1'</span>, <span class="string">'value1'</span>); <span class="comment">//Map &#123;"key1" =&gt; "value1"&#125;</span></span><br><span class="line">map.set(<span class="string">'key2'</span>, <span class="string">'value2'</span>); <span class="comment">//Map &#123;"key1" =&gt; "value1", "key2" =&gt; "value2"&#125;</span></span><br><span class="line">map.get(<span class="string">'key1'</span>); <span class="comment">//value1</span></span><br><span class="line">map.has(<span class="string">'key2'</span>); <span class="comment">//true</span></span><br><span class="line">map.delete(<span class="string">'key1'</span>); <span class="comment">//删除成功会返回true</span></span><br><span class="line">map.has(<span class="string">'key1'</span>); <span class="comment">//false</span></span><br><span class="line">map.clear(); <span class="comment">//清空所有</span></span><br></pre></td></tr></table></figure>
<p>而对于map的遍历可以使用<code>forEach</code>语法,其中的回调函数同样是接收三个参数：<code>value,key,context</code>。当然context是可选的。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'key1'</span>, <span class="string">'value1'</span>); </span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'key2'</span>, <span class="string">'value2'</span>); </span><br><span class="line"><span class="built_in">map</span>.forEach((value,key) =&gt; console.<span class="keyword">log</span>(value));</span><br><span class="line"><span class="comment">//value1, value2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="WeakSet和WeakMap"><a href="#WeakSet和WeakMap" class="headerlink" title="WeakSet和WeakMap"></a>WeakSet和WeakMap</h2><p>WeakMap和WeakSet一样，存储了是对象的弱引用方式。而Set和Weak的实例中，则是采用了强引用的方式，只要<code>Set</code>或<code>Map</code>的实例存在，其中所存储的对象就无法被垃圾回收机制回收，从而无法释放内存。利用WeakSet和WeakMap的弱引用方式，则可以在内存管理上有着更加容易优化的空间。</p>
</div><div class="tags"><a href="/tags/javascript/">javascript</a><a href="/tags/es6/">es6</a></div><div class="post-nav"><a class="pre" href="/2017/03/09/ES6语言特性的总结-3/">ES6语言特性的总结(3)</a><a class="next" href="/2017/02/26/ES6语言特性的总结-1/">ES6语言特性的总结(1)</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'scq000',
  repo: 'hexo-gitment',
  oauth: {
    client_id: '59f70dc7536c628210ce',
    client_secret: '59ee1a9db906805480c908772285fa5099c820c8',
  },
  id: 'ES6语言特性的总结(2)'
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/正则/" style="font-size: 15px;">正则</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/flexbox/" style="font-size: 15px;">flexbox</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/理解Redux中间件/">理解Redux中间件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/React中的五种组件形式/">React中的五种组件形式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/24/浅谈性能优化之Tree-Shaking/">浅谈性能优化之Tree Shaking</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/08/那些年，那些跨域问题/">那些年，那些跨域问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/响应式图片的处理/">响应式图片的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/ES6语言特性的总结-3/">ES6语言特性的总结(3)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/01/ES6语言特性的总结-2/">ES6语言特性的总结(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/26/ES6语言特性的总结-1/">ES6语言特性的总结(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/06/设计模式之状态模式/">设计模式之状态模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/IOS-Input-Disabled默认样式问题/">IOS Input Disabled默认样式问题</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Paolino.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>前端模块化的前世今生 | Paolino</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">前端模块化的前世今生</h1><a id="logo" href="/.">Paolino</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">前端模块化的前世今生</h1><div class="post-meta">Apr 3, 2019</div><div class="post-content"><p>凡是开发大型应用程序，模块块必然是不可或缺的一部分。那么什么是模块化呢？其实<em>模块化</em>就是<strong>将一个复杂的系统分解成多个独立的模块的代码组织方式</strong>。在很长的一段时间里，前端只能通过一系列的<code>&lt;script&gt;</code>标签来维护我们的代码关系，但是一旦我们的项目复杂度提高的时候，这种简陋的代码组织方式便是如噩梦般使得我们的代码变得混乱不堪。所以，在开发大型Javascript应用程序的时候，就必须引入模块化机制。由于早期官方并没有提供统一的模块化解决方案，所以在群雄争霸的年代，各种前端模块化方案层出不穷。本文将从最早期的IFEE闭包方案到现在的ES6 Modules， 追根溯源，带你详细了解前端模块化的前世今生。</p>
<h1 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h1><p>模块化的一大作用就是用来隔离作用域，避免变量冲突。而Javascript没有语言层面的命名空间概念，只能将代码暴露到全局作用域下。在刀耕火种的年代，作为脚本语言的Javascript为了避免全局变量污染，只能使用闭包来实现模块化。好在我们可以利用自执行函数（IIFE)来执行代码，从而避免变量名泄漏到全局作用域中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">window</span>.jQuery = &#123;</span><br><span class="line">       <span class="comment">// 这里是代码 </span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>虽然IIFE可以有效解决命名冲突的问题，但是对于依赖管理，还是束手无策。由于浏览器是从上至下执行脚本，因此为了维持脚本间的依赖关系，就必须手动维护好<code>script</code>标签的相对顺序。</p>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>AMD (Asynchronous Module Definition）也是一种 JavaScript模块化规范。从名字上可以看出，它主要提供了异步加载的功能。对于多个JS模块之间的依赖问题，如果使用原生的方式加载代码，随着加载文件的增多，浏览器会长时间地失去响应，而AMD能够保证被依赖的模块尽早地加载到浏览器中，从而提高页面响应速度。由于该规范原生Javascript无法支持，所以必须使用相应的库来实现对应的模块化。<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">RequireJS</a>就是实现了该规范的类库，实际上AMD也是其在推广过程中的产物。</p>
<p>利用RequireJS来编写模块，所有的依赖项必须提前声明好。在导入模块的时候，也会先加载对应的依赖模块，然后再执行接下来的代码，同时AMD模块可以并行加载所有依赖模块，从而很好地提高页面加载性能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'./index.js'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">code</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD(Common Module Definition)最初是由阿里的玉伯提出的，同AMD类似，使用CMD模块也需要使用对应的库<a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">SeaJS</a>。SeaJS所要解决的问题和requireJS一样，但是在使用方式和加载时机上有所不同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过require引用模块</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> path=<span class="built_in">require</span>.resolve(<span class="string">'./cmdDefine'</span>);</span><br><span class="line"></span><br><span class="line">   alert(path);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。如果使用require.async()方法，可以实现模块的懒加载。</p>
<h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>随着Javasript应用进军服务器端，业界急需一种标准的模块化解决方案，于是，CommonJS(<a href="http://www.commonjs.org)应运而生。它最初是由Kevin" target="_blank" rel="noopener">www.commonjs.org)应运而生。它最初是由Kevin</a> Dangoor在他的<a href="https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/" target="_blank" rel="noopener">这篇博文</a>中首次提出。</p>
<p>这是一种被广泛使用的Javascript模块化规范，大家最熟悉的Node.js应用中就是采用这个规范。在Node.js中，内置了module对象用来定义模块, require函数用来加载模块文件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js 模块定义</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: add</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(utils.add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>此种模块化方案特点就是：同步阻塞式加载，无法实现按需异步加载。另外，如果想要在浏览器中使用CommonJS模块就需要使用<code>Browserify</code>进行解析：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install browserify -g</span><br><span class="line">browserify utils.js &gt;　bundle.js</span><br></pre></td></tr></table></figure>
<p>当然，你也可以使用gulp, webpack等工具进行解析打包后引入到浏览器页面中去。</p>
<h1 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h1><p>上面介绍的CommonJS和AMD等模块化方案都是针对特定的平台，如果想要实现跨平台的模块化，就得引入UMD的模块化方式。UMD是通用模块定义(Universal Module Definition)的缩写，使用该中模块化方案，可以很好地兼容AMD， CommonJS等模块化语法。</p>
<p>接下来，让我们通过一个简单地例子看一下如何使用和定义UMD模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line"></span><br><span class="line">    define([<span class="string">'jquery'</span>], factory);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">'object'</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> jquery = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>.exports = factory(jquery);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">    root.UmdModule = factory(root.jQuery);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">jquery</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 现在你可以利用jquery做你想做的事了</span></span><br><span class="line">    </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>这种模块定义方法，可以看做是IIFE的变体。不同的是它倒置了代码的运行顺序，需要你将所需运行的函数作为第二个参数传入。由于这种通用模块的适用性强，很多JS框架和类库都会打包成这种形式的代码。</p>
<h1 id="ES6-Modules"><a href="#ES6-Modules" class="headerlink" title="ES6 Modules"></a>ES6 Modules</h1><p>对于ES6来说，不必再使用闭包和封装函数等方式进行模块化支持了。在ES6中，从语法层面就提供了模块化的功能。然而受限于浏览器的实现程度，如果想要在浏览器中运行，还是需要通过Babel等转译工具进行编译。ES6提供了<code>import</code>和<code>export</code>命令，分别对应模块的导入和导出功能。具体实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo-export.js 模块定义</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"scq000"</span></span><br><span class="line"><span class="keyword">var</span> sayHello = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi，"</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;name, sayHello&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo-import.js 使用模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;sayHello&#125; <span class="keyword">from</span> <span class="string">"./demo-export"</span>;</span><br><span class="line">sayHello(<span class="string">"scq000"</span>);</span><br></pre></td></tr></table></figure>
<p>对于具体的语法细节，想必大家在日常使用过程中都已经轻车熟路了。但对于ES6模块化来说，有以下几点特性是需要记住的：</p>
<ul>
<li>ES6使用的是基于文件的模块。所以必须一个文件一个模块，不能将多个模块合并到单个文件中去。</li>
<li>ES6模块API是静态的，一旦导入模块后，无法再在程序运行过程中增添方法。</li>
<li>ES6模块采用引用绑定（可以理解为指针)。这点和CommonJS中的值绑定不同，如果你的模块在运行过程中修改了导出的变量值，就会反映到使用模块的代码中去。所以，不推荐在模块中修改导出值，导出的变量应该是静态的。</li>
<li>ES6模块采用的是单例模式，每次对同一个模块的导入其实都指向同一个实例。</li>
</ul>
<h1 id="Webpack中的模块化方案"><a href="#Webpack中的模块化方案" class="headerlink" title="Webpack中的模块化方案"></a>Webpack中的模块化方案</h1><p>作为现代化的前端构建工具，Webpack还提供了丰富的功能能够使我们更加轻易地实现模块化。利用Webpack，你不仅可以将Javascript文件进行模块化，同时还能针对图片，css等静态资源进行模块化。你可以在代码里使用CommonJS, ES6等模块化语法，打包的时候你也可以根据需求选择打包类型，如UMD, AMD等：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  //...</span><br><span class="line">  output: &#123;</span><br><span class="line">    library: 'librayName',</span><br><span class="line">    libraryTarget: 'umd', // 配置输出格式</span><br><span class="line">    filename: 'bundle.js'</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，ES6模块好处很多，但是并不支持按需加载的功能, 而按需加载又是Web性能优化中重要的一个环节。好在我们可以借助Webpack来弥补这一缺陷。Webpack v1版本提供了<code>require.ensure</code>API, 而2.x之后使用了<code>import()</code>函数来实现异步加载。具体的代码示例可以查看我之前所写的<a href="https://juejin.im/post/59b73ef75188253db70acdb5#heading-11" target="_blank" rel="noopener">前端性能优化之加载技术</a> 这篇文章。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>模块化方案解决了代码之间错综复杂的依赖关系，不仅降低了开发难度同时也让开发者将精力更多地集中在业务开发中。随着ES6标准的推出，模块化直接成为了Javascript语言规范中的一部分。这也意味着CommonJS, AMD, CMD等模块化方案终将退出历史的舞台。当然，要实现完全ES6模块化的使用，还需要一段长时间的等待。那么，在这段过渡的时间里，我们可能仍然需要维护旧有的代码，使用传统的模块化方案来构建应用。对于前端工程师来说，系统地了解主流的模块化方案就显得十分必要了。最后，让我们再一次回顾一下各种模块化方式的特点：</p>
<table>
<thead>
<tr>
<th>模块化方案</th>
<th>加载</th>
<th>同步/异步</th>
<th>浏览器</th>
<th>服务端</th>
<th>模块定义</th>
<th>模块引入</th>
</tr>
</thead>
<tbody>
<tr>
<td>IFEE</td>
<td>取决于代码</td>
<td>取决于代码</td>
<td>支持</td>
<td>支持</td>
<td>IFEE</td>
<td>命名空间</td>
</tr>
<tr>
<td>AMD</td>
<td>提前预加载</td>
<td>异步</td>
<td>支持</td>
<td>构建工具r.js</td>
<td>define</td>
<td>require</td>
</tr>
<tr>
<td>CMD</td>
<td>按需加载</td>
<td>延迟执行</td>
<td>支持</td>
<td>构建工具spm</td>
<td>define</td>
<td>define</td>
</tr>
<tr>
<td>Common</td>
<td>值拷贝，运行时加载</td>
<td>同步</td>
<td>原生不支持，需要使用browserify提前打包编译</td>
<td>原生支持</td>
<td>module.exports</td>
<td>require</td>
</tr>
<tr>
<td>UMD</td>
<td>取决于代码</td>
<td>取决于代码</td>
<td>支持</td>
<td>支持</td>
<td>IFEE</td>
<td>命名空间</td>
</tr>
<tr>
<td>ES Modules(ES6)</td>
<td>实时绑定,动态绑定，编译时输出</td>
<td>同步</td>
<td>需用babel转译</td>
<td>需用babel转译</td>
<td>export</td>
<td>import</td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><em>参考资料</em></h1><p><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html</a></p>
<p>《你不知道的Javascript》</p>
<p><a href="https://www.infoq.cn/article/es6-in-depth-modules?utm_source=articles_about_ES6-In-Depth&amp;utm_medium=link&amp;utm_campaign=ES6-In-Depth" target="_blank" rel="noopener">https://www.infoq.cn/article/es6-in-depth-modules?utm_source=articles_about_ES6-In-Depth&amp;utm_medium=link&amp;utm_campaign=ES6-In-Depth</a></p>
<p>——本文首发于个人公众号，转载请注明出处———</p>
<p><img src="http://upload-images.jianshu.io/upload_images/112263-52720365a3c429f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信扫描二维码，关注我的公众号"><br>最后，欢迎大家关注我的公众号，一起学习交流。</p>
</div><div class="tags"><a href="/tags/模块化/">模块化</a></div><div class="post-nav"><a class="pre" href="/2019/05/16/正则表达式不要背/">正则表达式不要背</a><a class="next" href="/2018/08/26/理解Redux中间件/">理解Redux中间件</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/正则/" style="font-size: 15px;">正则</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/flexbox/" style="font-size: 15px;">flexbox</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a> <a href="/tags/css-grid/" style="font-size: 15px;">css,grid</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/神奇的Lambda表达式——函数式编程必学/">神奇的Lambda表达式——函数式编程必学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/ES2019新特性预览/">ES2019新特性预览</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/CSS-Grid-网格布局全攻略/">CSS Grid 网格布局全攻略</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/正则表达式不要背/">正则表达式不要背</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/03/前端模块化的前世今生/">前端模块化的前世今生</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/理解Redux中间件/">理解Redux中间件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/React中的五种组件形式/">React中的五种组件形式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/24/浅谈性能优化之Tree-Shaking/">浅谈性能优化之Tree Shaking</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/08/那些年，那些跨域问题/">那些年，那些跨域问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/响应式图片的处理/">响应式图片的处理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Paolino.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
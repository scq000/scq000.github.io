<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>神奇的Lambda表达式——函数式编程必学 | Paolino</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">神奇的Lambda表达式——函数式编程必学</h1><a id="logo" href="/.">Paolino</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">神奇的Lambda表达式——函数式编程必学</h1><div class="post-meta">Aug 30, 2019</div><div class="post-content"><p>作为一名有追求的程序员，对于计算机基础的理论一定要有所了解。最近几年，随着分布式、云计算等技术的发展，函数式编程语言也趋于流行。如果要学习函数式编程，一定要深入理解它背后的理论知识。从收益的角度上讲，这些基础理论知识几十年不变，是十分值得花时间进行学习的。lambda演算(Lambda Calculus)就属于这样一套理论，可以说它在函数式编程领域就如牛顿万有引力定律一样基础。接下来这篇文章我将主要介绍lambda演算的基本知识，最后我还会尝试用es6的箭头函数来演示如何利用lambda演算来实现编程语言中的基本组成要素。</p>
<h1 id="lambda演算是什么？"><a href="#lambda演算是什么？" class="headerlink" title="lambda演算是什么？"></a>lambda演算是什么？</h1><p><img src="https://upload-images.jianshu.io/upload_images/112263-b72566be5f3787e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image result for lambda calculus.png"></p>
<p>要了解一个事物，先了解它的历史一定是重中之重。lamda表达式最初是由一个美国普林斯顿大学的数学家Alonzo Church在1932年所发明的。他也是”计算机科学之父”——图灵的博士生导师。</p>
<p>我们都知道现代的计算机基本上都是基于图灵机的。在图灵机中，所有的计算过程其实都是基于状态的，这也是为什么我们平常写代码要声明并使用变量的原因：<strong>变量主要作用就是用来存储状态</strong>。而Alonzo Church所提出的lamda演算(lamda calcus)模型实际上是基于函数的。图灵机模型和Lambda演算模型虽然是两种不同的理论模型，但它们实际上是等价的，这也意味着，任何基于图灵机的计算机程序都能等价地翻译成基于lambda演算模型的程序。</p>
<p>lambda演算是一套研究函数定义、函数应用和递归的形式系统。它基本的组成部分就是三种表达式: 1. 函数定义 2. 标识符引用 3.函数应用。</p>
<p>那么到底什么是lamda表达式呢，它又是由哪些基本组成要素构成的呢？我们都知道在函数式编程语言里面，最基本的组成单位就是函数。lambda表达式从定义上来讲可以看做是一个匿名的纯函数。ES6中引入了箭头函数，它的本质实际上就是我们这里所说的lambda表达式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lambda = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>实际上现在大部分的编程语言都引入了lambda表达式这一特性，如Java, c#和es6等。我们通常将lambda表达式，看作是一个黑盒，只关心它的输入和输出。由于没有内部状态，用函数式编程的思想写代码就与用命令式语言写代码截然不同。作为一个纯函数，每一次运行定义好的lambda表达式的时候，结果都应该是一致的。</p>
<p>在纯粹的lambda演算中实际上是没有任何内置的数据结构和逻辑控制语句的，但是我们可以使用函数来建构整个编程语言的所有要素。</p>
<p>lambda演算中的一些基本规则，可以类比到我们比较熟悉的ES6语法:</p>
<table>
<thead>
<tr>
<th></th>
<th>lambda表达式</th>
<th>ES6 箭头函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义函数</td>
<td>λx.x</td>
<td>x =&gt; x</td>
</tr>
<tr>
<td>柯里化 curry</td>
<td>λx. λy.x+y</td>
<td>x =&gt; y =&gt; x + y</td>
</tr>
<tr>
<td>应用 application</td>
<td>(λx. λy.x+y) 5 1</td>
<td>(x =&gt; y =&gt; x + y) (5) (1)</td>
</tr>
</tbody>
</table>
<h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>在实现具体的逻辑之前，我们需要明确的一点是：在lambda演算中，lambda表达式本身既可以是操作数也可以是函数，就好像一只鸡(lambda表达式），既可以吃虫子（另一个lambda表达式)，也可以被狐狸(还有一个lambda表达式) 吃（请原谅我这糟糕的类比），它们统称为动物(lambda表达式）。归根结底就是，在这个封闭的概念世界里，只有一类事物，那就是lambda表达式(函数)，我们可以利用这个最基础的概念生成其它的概念和运算逻辑。</p>
<p>在纯粹的函数式编程世界里，没有1,2,3这样的数字也没有+-*/这样的基本运算符，所以这些我们都需要自己手动去实现。</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>首先作为一门计算机设计语言，数字是关键，所谓”数是万物本源“在计算机世界里简直就是真理。那么我们如何利用lamda表达式来表示数呢？在这里，我们采用函数调用次数来表示自然数，用这样的编码方式表示的自然数也叫<em>邱奇数</em>。</p>
<p>有了理论的指导，我们很容易就能写出下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ZERO = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> x;</span><br><span class="line"><span class="keyword">const</span> ONE = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> f(x);</span><br><span class="line"><span class="keyword">const</span> TWO = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> f(f(x));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有了数字后，然后还需要再定义一个转换函数，它可以将<code>ZERO</code>和<code>ONE</code>这种函数式定义转成我们所熟悉的数字，方便调试。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toNumber = <span class="function"><span class="params">n</span> =&gt;</span> n(<span class="function"><span class="params">i</span> =&gt;</span> i+<span class="number">1</span>)(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(toNumber(ONE));</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>经过上面的步骤，我们就定义了最基本的数字。有了这些数字，我们应该如何去做一些简单的加减乘除运算呢？既然数字表示的是调用函数次数的多少，那么在这里对于加法运算，我们也可以将它定义成调用函数的次数的相加。例如，要表示1+2等于3这一过程，输入的函数就应该调用三次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">n</span> =&gt;</span> <span class="function"><span class="params">m</span> =&gt;</span> <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> m(fn)(n(fn)(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TWO = add(ONE)(ONE);</span><br><span class="line"><span class="keyword">const</span> THREE = add(ONE)(TWO);</span><br><span class="line">toNumber(THREE);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>其中n和m表示add操作的两个操作数。</p>
<p>﻿接着我们再来实现乘法，回顾一下大家小时候学习乘法的过程。<code>n * m</code>的一个朴素定义可以表示成： n个m相加。那么在这里，我们需要实现的就是先调用n次函数，将它的结果再调用m次。表示到代码中就像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function"><span class="params">n</span> =&gt;</span> <span class="function"><span class="params">m</span> =&gt;</span> <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> m(n(fn))(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = toNumber(multiply(TWO)(THREE));</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>至于减法和除法，实现起来相对来说比较复杂，大家如果感兴趣的话，可以参考其他的资料进行学习。</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>接下来我们再进一步考虑一下如何实现条件分支语句。条件分支语句中一个很重要的元素就是布尔值，先来定义TRUE和FALSE这两个基本的布尔值类型:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TRUE = <span class="function"><span class="params">first</span> =&gt;</span> <span class="function"><span class="params">second</span> =&gt;</span> first;</span><br><span class="line"><span class="keyword">const</span> FALSE = <span class="function"><span class="params">first</span> =&gt;</span> <span class="function"><span class="params">second</span> =&gt;</span> second;</span><br></pre></td></tr></table></figure>
<p>它表示的是从两个事物中选择其中一个事物，TRUE表示选择的第一个，而FALSE与之相反，选择的是第二个。</p>
<p>定义好基本的布尔值类型，再实现条件分支语句就很简单了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ifElse = <span class="function"><span class="params">boolFn</span> =&gt;</span> <span class="function"><span class="params">first</span> =&gt;</span> <span class="function"><span class="params">second</span> =&gt;</span> boolFn(first)(second);</span><br><span class="line"><span class="comment">// ifElse(TRUE)(x)(y) ===&gt; x</span></span><br><span class="line"><span class="comment">// ifElse(FALSE)(x)(y) ===&gt; y</span></span><br></pre></td></tr></table></figure>
<p>再增加一个转换函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toBoolean = <span class="function"><span class="params">boolFn</span> =&gt;</span> boolFn(<span class="literal">true</span>)(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toBoolean(TRUE));</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>大功告成，Bingo!</p>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>利用上述定义的布尔值，推导出三大逻辑运算：与（and)、或（or)、非（not)就顺理成章了。反转逻辑最简单，只要将上面定义条件分支语句的逻辑反过来就可以了。这与布尔值的定义也是强联系，如果说TRUE表示的是选择第一个分支条件，那么not就要反转这种逻辑:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> not = <span class="function"><span class="params">boolFn</span> =&gt;</span> <span class="function"><span class="params">first</span> =&gt;</span> <span class="function"><span class="params">second</span> =&gt;</span> boolFn(second)(first);</span><br><span class="line">toBoolean(not(TRUE));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>至于或运算符，实质上应该是个带有两个操作数的运算，所以我们需要定义个高阶函数，需要调用两次，每次接收一个操作数。根据之前的定义，我们知道TRUE会返回第一个变量，FALSE会返回第二个变量。而或运算(or)的意思是只要两个操作数中有一个TRUE，就返回TRUE。那么我们只要使变量应用的顺序和调用顺序一致，就能保证当TRUE作为第一个参数时，正好应用到TRUE函数上, 当FALSE作为第一个参数时，函数返回第二个参数的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> or = <span class="function"><span class="params">first</span> =&gt;</span> <span class="function"><span class="params">second</span> =&gt;</span> first(first)(second);</span><br><span class="line">toBoolean(or(TRUE)(FALSE)); <span class="comment">// true</span></span><br><span class="line">toBoolean(or(FALSE)(FALSE)); <span class="comment">// false</span></span><br><span class="line">toBoolean(or(TRUE)(FALSE)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>与操作与或操作相似，我们要保证当两个操作数都是TRUE的时候才会返回TRUE。将上面的实现逻辑反转一下，就能得到下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> and = <span class="function"><span class="params">first</span> =&gt;</span> <span class="function"><span class="params">second</span> =&gt;</span> first(second)(first);</span><br><span class="line">toBoolean(and(FALSE)(FALSE)); <span class="comment">// false</span></span><br><span class="line">toBoolean(and(FALSE)(TRUE)); <span class="comment">// false</span></span><br><span class="line">toBoolean(and(TRUE)(TRUE)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这块逻辑可能比较绕，大家可以用心体会一下。</p>
<h2 id="递归-Y组合子"><a href="#递归-Y组合子" class="headerlink" title="递归(Y组合子)"></a>递归(Y组合子)</h2><p><img src="https://upload-images.jianshu.io/upload_images/112263-21bfa143142f8a7f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="M.C. Escher – Drawing Hands.jpg"></p>
<p>我们先从一个最简单的递归定义说起，下面这个故事想必大家都有听说过:</p>
<blockquote>
<p>从前有座山，山里有座庙，庙里有个老和尚和小和尚，有一天老和尚对小和尚讲故事，讲的什么故事呢？从前有座山，山里有座庙，庙里有个老和尚和小和尚…</p>
</blockquote>
<p>这样一个不停的引用自身的概念，其实就是递归的简单定义。</p>
<p>有了递归的定义后，我们再来深入思考一下，如何用lambda表达式来实现递归的基本逻辑。</p>
<p>这里我举一个简单的斐波那契数列的例子(1, 2, 6, 24…)，如果语言中已经支持递归，很容易可以写出这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factrial =&gt; <span class="function"><span class="params">n</span> =&gt;</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * factrial(n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>如果语言中不支持递归，那么在lambda表达式中，我们并不能直接利用factorial这个名字来引用其自身。</p>
<p>不过可以换个思路，既然不能在函数声明里面使用未定义的函数名，那么我们可以将这个函数定义以参数的形式传进去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeFactorial = <span class="function"><span class="params">factroial</span> =&gt;</span> <span class="function"><span class="params">n</span> =&gt;</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * factroial(n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>有了一个makeFactorial后，怎么使用呢? 假设，现在已经有了一个seed函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seed = <span class="function"><span class="params">n</span> =&gt;</span> n;</span><br></pre></td></tr></table></figure>
<p>它其实啥都没干，不过我们可以利用seed函数生成factorial0：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial0 = makeFactorial(seed)</span><br></pre></td></tr></table></figure>
<p>很容易知道，factorial0函数展开后是这样的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial0 = <span class="function"><span class="params">n</span> =&gt;</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * (<span class="function"><span class="params">n</span> =&gt;</span> n)(n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>我们知道这个函数在参数n等于0的时候结果是对的，而n等于其它数值的时候结果是0，显然不正确。不过，别着急，我们可以利用factorial0进一步构造factorial1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial1 = makeFactorial(factorial0)</span><br></pre></td></tr></table></figure>
<p>它展开后:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial1 = <span class="function"><span class="params">n</span> =&gt;</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * factorial0(n - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这个函数在n等于1的时候结果等于 <code>1 * factorial0(0)</code>, 已知n 等于 0 时候，factorial0的结果是正确的，所以factorial1在n 等于0 和 n等于1的时候也都能正常工作。</p>
<p>同样的原理，我们可以继续构造出factorail2, factorial3, factorial4….</p>
<p>所以可以归纳出通用的factorial函数定义应该是长这个样子的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorialn = makeFactorial(makeFactorial(...)); <span class="comment">// 无穷个makeFactorial</span></span><br></pre></td></tr></table></figure>
<p>到这里，我们进一步思考🤔，有没有什么办法能让这个makeFactorial函数不停递归下去呢？</p>
<p>我们先定义一个基本循环函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loop = <span class="function"><span class="params">x</span> =&gt;</span> x(x);</span><br></pre></td></tr></table></figure>
<p>这样当我用这个函数调用makeFactorial的时候，就会调用makeFactorial(makeFactorial)，不过这样的定义好像缺少动力。要让它不停循环下去，我们可以让它再自身调用一次：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loop = (<span class="function"><span class="params">x</span> =&gt;</span> x(x))(<span class="function"><span class="params">x</span> =&gt;</span> x(x))</span><br></pre></td></tr></table></figure>
<p>可以看到当你将<code>x = x =&gt; x(x)</code>代入到<code>loop</code>函数后，展开结果如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loop = (<span class="function"><span class="params">x</span> =&gt;</span> x(x))(<span class="function"><span class="params">x</span> =&gt;</span> x(x))</span><br></pre></td></tr></table></figure>
<p>是不是又回到之前的定义了？</p>
<p>不过这样一个函数在javascript中使用是不行的，因为在javascript中参数是计算完后再传入到函数中去的，所以我们要延迟参数的计算， 将代码改成如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loop = (<span class="function"><span class="params">x</span> =&gt;</span> x(x))(<span class="function"><span class="params">y</span> =&gt;</span> x(x)(y))</span><br></pre></td></tr></table></figure>
<p>引入参数y后，只有最终展开到最后一层的时候，才会开始计算值，这也是延迟计算的思想。</p>
<p>有了这个loop函数后，我们最终的factorial函数就很容易构造了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = loop(makeFactorial);</span><br></pre></td></tr></table></figure>
<p>我们在控制台试一下效果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">4</span>) = <span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>实际上上面定义的那个<code>loop</code>函数，它就叫做<strong>Y组合子（Y combinator)</strong>。这也是在lambda演算中非常著名的一个概念，它是在不支持递归的编程语言中实现递归的关键，也是学习lambda演算理论的一个难点。要彻底理解它可能还需要多花点时间思考。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>﻿至此，我们已经实现了数据，计算，逻辑和控制语句还有最重要的递归。这几个部分其实是编程语言中最核心的组成部分。从一个基本的组成元素——函数，再通过几个法则，就可以构建成整个计算机编程语言的核心要素，这就是lambda演算的神奇之处。</p>
<p>当然，整个lambda演算的理论要彻底理解肯定是不那么容易的，这篇文章也只是个人学习后的一些思路梳理，难免有所错漏。大家如果在阅读过程中，发现有不对的地方，欢迎交流指正。</p>
<p>——–转载请注明出处–———</p>
<p><img src="https://upload-images.jianshu.io/upload_images/112263-d3bc21b04d47825f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信扫描二维码，关注我的公众号.jpg"><br>最后，欢迎大家关注我的公众号，一起学习交流。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://cgnail.github.io/academic/lambda-1/" target="_blank" rel="noopener">http://cgnail.github.io/academic/lambda-1/</a></p>
<p><a href="http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/" target="_blank" rel="noopener">http://mindhacks.cn/2006/10/15/cantor-godel-turing-an-eternal-golden-diagonal/</a></p>
<p><a href="https://mvanier.livejournal.com/2897.html" target="_blank" rel="noopener">https://mvanier.livejournal.com/2897.html</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E6%95%B0?wprov=sfla1" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E6%95%B0?wprov=sfla1</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90?wprov=sfla1" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90?wprov=sfla1</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9?wprov=sfla1" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9?wprov=sfla1</a></p>
</div><div class="tags"><a href="/tags/函数式编程/">函数式编程</a></div><div class="post-nav"><a class="next" href="/2019/08/12/ES2019新特性预览/">ES2019新特性预览</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/vuex/" style="font-size: 15px;">vuex</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/技术/" style="font-size: 15px;">技术</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/正则/" style="font-size: 15px;">正则</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/flexbox/" style="font-size: 15px;">flexbox</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/异步/" style="font-size: 15px;">异步</a> <a href="/tags/函数式编程/" style="font-size: 15px;">函数式编程</a> <a href="/tags/css-grid/" style="font-size: 15px;">css,grid</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/跨域/" style="font-size: 15px;">跨域</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/神奇的Lambda表达式——函数式编程必学/">神奇的Lambda表达式——函数式编程必学</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/12/ES2019新特性预览/">ES2019新特性预览</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/17/CSS-Grid-网格布局全攻略/">CSS Grid 网格布局全攻略</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/正则表达式不要背/">正则表达式不要背</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/26/理解Redux中间件/">理解Redux中间件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/React中的五种组件形式/">React中的五种组件形式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/24/浅谈性能优化之Tree-Shaking/">浅谈性能优化之Tree Shaking</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/08/那些年，那些跨域问题/">那些年，那些跨域问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/响应式图片的处理/">响应式图片的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/ES6语言特性的总结-3/">ES6语言特性的总结(3)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Paolino.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>